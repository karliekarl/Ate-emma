"""
UPC Validator: Real-Time Barcode Checker & Decoder

A complete Windows desktop application built with Tkinter only (pure Python + standard library),
providing real-time validation for UPC-A and UPC-E barcodes, optional webcam scanning using
OpenCV (cv2) and pyzbar if installed, barcode generation and preview, batch validation,
export to CSV/PDF, history management, and a polished UI with light/dark modes.

Note: Webcam scanning requires third-party libraries (cv2 and pyzbar). The rest of the app uses
only the Python standard library and Tkinter. If scanning libraries are unavailable, scanning is
cleanly disabled.

Author: Generated by an AI assistant
"""
from __future__ import annotations

import base64
import csv
import io
import os
import queue
import re
import struct
import sys
import threading
import time
import traceback
import zlib
from dataclasses import dataclass
from typing import Callable, Dict, List, Optional, Tuple

# Tkinter imports
import tkinter as tk
from tkinter import ttk, messagebox, filedialog

# Optional Windows sound
try:
    import winsound  # type: ignore
except Exception:  # pragma: no cover
    winsound = None  # Fallback to Tk bell

# Optional scanning dependencies
try:
    import cv2  # type: ignore
except Exception:  # pragma: no cover
    cv2 = None

try:
    from pyzbar import pyzbar  # type: ignore
except Exception:  # pragma: no cover
    pyzbar = None


# ------------------------------ UPC VALIDATION LOGIC ------------------------------
class UPCValidator:
    """Core logic for UPC-A and UPC-E validation, decoding, and solving missing digits.

    Features:
    - Accepts UPC-A (12 digits) or UPC-E (6 or 8 digits including number system/check)
    - Real-time validation and error diagnostics
    - Solve for a single missing digit using '?' placeholder
    - Decodes product type, manufacturer, product, check digit
    - Accepts EAN-13 with leading '0' as UPC-A
    """

    PRODUCT_TYPE_MAP: Dict[str, str] = {
        '0': 'General groceries',
        '2': 'Meat and produce',
        '3': 'Drugs & health products',
        '4': 'Non-food items',
        '5': 'Coupons',
        '6': 'Other items',
        '7': 'Other items',
        '1': 'Reserved for future use',
        '8': 'Reserved for future use',
        '9': 'Reserved for future use',
    }

    @staticmethod
    def sanitize(code: str) -> str:
        """Keep only digits and a single '?' placeholder; also allow spaces/hyphens in input.

        Returns the sanitized string. Multiple '?' are permitted temporarily; logic will handle.
        """
        if not code:
            return ''
        code = code.strip()
        # Remove spaces and hyphens commonly typed
        code = re.sub(r"[\s\-]", "", code)
        # Allow digits and '?'
        code = re.sub(r"[^0-9\?]", "", code)
        return code

    @staticmethod
    def compute_check_digit(upc11: str) -> int:
        """Compute UPC-A check digit for the first 11 digits using the standard formula.

        Formula: 3*a1 + a2 + 3*a3 + a4 + 3*a5 + a6 + 3*a7 + a8 + 3*a9 + a10 + 3*a11 + a12 ≡ 0 (mod 10)
        Rearranged to compute a12 from first 11 digits: (10 - (sum % 10)) % 10
        """
        if len(upc11) != 11 or not upc11.isdigit():
            raise ValueError("compute_check_digit requires 11 digits")
        total = 0
        for idx, ch in enumerate(upc11):
            digit = ord(ch) - 48
            # Positions are 1-based in formula: odd positions get weight 3
            weight = 3 if (idx % 2 == 0) else 1
            total += weight * digit
        check = (10 - (total % 10)) % 10
        return check

    @staticmethod
    def expand_upce_to_upca(upce: str, number_system: str = '0') -> str:
        """Expand a 6-digit UPC-E code into the equivalent 12-digit UPC-A (without computing check).

        Rules (X1..X6 are the six UPC-E digits):
        - If X6 in {0,1,2}: Manufacturer = X1 X2 X6; Product = 0000 X3 X4 X5
        - If X6 == 3:       Manufacturer = X1 X2 X3; Product = 00000 X4 X5
        - If X6 == 4:       Manufacturer = X1 X2 X3 X4; Product = 00000 X5
        - If X6 in 5..9:    Manufacturer = X1 X2 X3 X4 X5; Product = 0000 X6
        UPC-A = NS + Manufacturer(5) + Product(5) + CheckDigit
        The returned string is first 11 digits (without check); caller should compute check digit
        or append supplied check.
        """
        if len(upce) != 6 or not upce.isdigit():
            raise ValueError("UPC-E must be 6 digits for expansion")
        x = [c for c in upce]
        x6 = x[5]
        if x6 in '012':
            manufacturer = f"{x[0]}{x[1]}{x6}00"
            product = f"00{x[2]}{x[3]}{x[4]}"
        elif x6 == '3':
            manufacturer = f"{x[0]}{x[1]}{x[2]}00"
            product = f"000{x[3]}{x[4]}"
        elif x6 == '4':
            manufacturer = f"{x[0]}{x[1]}{x[2]}{x[3]}0"
            product = f"0000{x[4]}"
        else:  # 5..9
            manufacturer = f"{x[0]}{x[1]}{x[2]}{x[3]}{x[4]}"
            product = f"0000{x6}"
        upc11 = f"{number_system}{manufacturer}{product}"
        if len(upc11) != 11:
            raise ValueError("Invalid UPC-E expansion result")
        return upc11

    @staticmethod
    def detect_type(code: str) -> Optional[str]:
        """Detect if code is UPC-A, UPC-E, or EAN-13-leading-0 (treated as UPC-A).
        Returns 'UPCA' or 'UPCE' or None if undetermined.
        """
        s = UPCValidator.sanitize(code)
        if not s:
            return None
        digits = s.replace('?', '')
        # EAN-13 with leading 0 -> UPC-A
        if len(digits) == 13 and digits.startswith('0') and '?' not in s:
            return 'UPCA'
        if len(s) in (12, 11, 13):
            return 'UPCA'
        if len(s) in (6, 7, 8):
            return 'UPCE'
        return None

    @staticmethod
    def normalize_to_upca(s: str) -> Tuple[Optional[str], Optional[str]]:
        """Attempt to normalize input to a 12-digit UPC-A string.
        Returns (upca12 or None, detected_type or None).
        Accepts EAN-13 with leading '0' by stripping the leading zero.
        """
        s = UPCValidator.sanitize(s)
        detected = UPCValidator.detect_type(s)
        if not s:
            return None, detected

        # EAN-13 leading 0 -> strip to 12
        if len(s) == 13 and s.startswith('0') and '?' not in s:
            s = s[1:]
            detected = 'UPCA'

        # UPC-A already
        if detected == 'UPCA':
            if '?' in s:
                # If single '?', brute force and return the first valid solution converted to full UPC-A
                sols = UPCValidator.solve_unknowns(s)
                if len(sols) == 1:
                    return sols[0], 'UPCA'
                return None, 'UPCA'
            if len(s) == 12 and s.isdigit():
                return s, 'UPCA'
            if len(s) == 11 and s.isdigit():
                check = UPCValidator.compute_check_digit(s)
                return s + str(check), 'UPCA'
            # Other lengths invalid/incomplete
            return None, 'UPCA'

        # UPC-E handling (6,7,8 digits). If 8, typically NS + 6 + check.
        if detected == 'UPCE':
            # Extract core digits and optional NS/check
            digits_only = s.replace('?', '')
            if '?' in s:
                sols = UPCValidator.solve_unknowns(s)
                if len(sols) == 1:
                    # Recurse with the solved code to normalize
                    return UPCValidator.normalize_to_upca(sols[0])
                return None, 'UPCE'

            if len(digits_only) == 6:
                upc11 = UPCValidator.expand_upce_to_upca(digits_only)
                check = UPCValidator.compute_check_digit(upc11)
                return upc11 + str(check), 'UPCE'
            if len(digits_only) == 8:
                ns = digits_only[0]
                core6 = digits_only[1:7]
                provided_check = digits_only[7]
                upc11 = UPCValidator.expand_upce_to_upca(core6, number_system=ns)
                calc_check = UPCValidator.compute_check_digit(upc11)
                if str(calc_check) == provided_check:
                    return upc11 + provided_check, 'UPCE'
                else:
                    return None, 'UPCE'
            # 7 digits (likely 6+check) is ambiguous without NS; treat as incomplete
            return None, 'UPCE'

        return None, None

    @staticmethod
    def validate(code: str) -> Dict[str, object]:
        """Validate the provided code, possibly containing one '?'.
        Returns a rich result dict with keys:
          - input: original input
          - sanitized: sanitized input
          - type: 'UPCA' | 'UPCE' | None
          - upca: 12-digit normalized UPC-A (if available)
          - valid: bool
          - complete: bool
          - error: Optional[str]
          - solved: Optional[Tuple[int, str]] (index, digit) if a single solution exists
          - decoded: Optional[Dict[str, str]] with keys product_type, manufacturer, product_code, check_digit
        """
        raw = code
        s = UPCValidator.sanitize(code)
        detected = UPCValidator.detect_type(s)
        result: Dict[str, object] = {
            'input': raw,
            'sanitized': s,
            'type': detected,
            'upca': None,
            'valid': False,
            'complete': False,
            'error': None,
            'solved': None,
            'decoded': None,
        }

        if not s:
            result['error'] = 'Empty input'
            return result

        # More than one unknown is unsupported for solving
        num_unknown = s.count('?')
        if num_unknown > 1:
            upca, t = UPCValidator.normalize_to_upca(s)
            result['type'] = t
            result['error'] = 'Multiple unknown digits (only one is supported)'
            return result

        # If exactly one unknown, brute force solutions
        if num_unknown == 1:
            solutions = UPCValidator.solve_unknowns(s)
            if len(solutions) == 1:
                solved_code = solutions[0]
                # Determine where the ? was and propagate this info downstream
                idx = s.index('?')
                solved_info = UPCValidator.validate(solved_code)
                try:
                    # Only set if not already present in solved_info
                    if not solved_info.get('solved'):
                        solved_info['solved'] = (idx, solved_code[idx])
                except Exception:
                    pass
                return solved_info
            elif len(solutions) > 1:
                result['error'] = 'Ambiguous digit: multiple solutions valid'
                return result
            else:
                result['error'] = 'No digit 0-9 makes this code valid'
                return result

        # No unknowns, normalize to UPC-A then compute validity
        upca, detected_type = UPCValidator.normalize_to_upca(s)
        result['type'] = detected_type
        result['upca'] = upca

        if upca is None:
            # Determine if incomplete or invalid
            digits_only = s
            if detected_type == 'UPCA':
                if len(digits_only) < 12:
                    result['error'] = 'Incomplete UPC-A (needs 12 digits)'
                else:
                    result['error'] = 'Invalid UPC-A'
            elif detected_type == 'UPCE':
                if len(digits_only.replace('?', '')) < 6:
                    result['error'] = 'Incomplete UPC-E'
                else:
                    result['error'] = 'Invalid UPC-E'
            else:
                result['error'] = 'Unrecognized code length'
            return result

        # Validate check digit
        check_calc = UPCValidator.compute_check_digit(upca[:11])
        check_given = int(upca[11])
        is_valid = (check_calc == check_given)
        result['valid'] = is_valid
        result['complete'] = True
        if not is_valid:
            result['error'] = f"Invalid check digit: expected {check_calc}, got {check_given}"
            return result

        # Decode
        result['decoded'] = UPCValidator.decode_upca(upca)
        return result

    @staticmethod
    def solve_unknowns(code: str) -> List[str]:
        """If code has exactly one '?', try all digits 0-9 and return all valid full codes.
        Works for both UPC-A and UPC-E, by validating the resulting code.
        """
        s = UPCValidator.sanitize(code)
        if s.count('?') != 1:
            return []
        idx = s.index('?')
        solutions: List[str] = []
        for d in '0123456789':
            candidate = s[:idx] + d + s[idx+1:]
            # Validate; if check passes (after normalization), accept
            upca, t = UPCValidator.normalize_to_upca(candidate)
            if upca is None:
                continue
            check_calc = UPCValidator.compute_check_digit(upca[:11])
            if int(upca[11]) == check_calc:
                solutions.append(candidate)
        return solutions

    @staticmethod
    def decode_upca(upca12: str) -> Dict[str, str]:
        """Decode a 12-digit UPC-A into components and human-friendly product type meaning."""
        if len(upca12) != 12 or not upca12.isdigit():
            raise ValueError("decode_upca requires 12 digits")
        product_type_digit = upca12[0]
        manufacturer = upca12[1:6]
        product_code = upca12[6:11]
        check_digit = upca12[11]
        meaning = UPCValidator.PRODUCT_TYPE_MAP.get(product_type_digit, 'Unknown')
        return {
            'product_type_digit': product_type_digit,
            'product_type_meaning': meaning,
            'manufacturer': manufacturer,
            'product_code': product_code,
            'check_digit': check_digit,
        }


# ------------------------------ BARCODE GENERATOR ------------------------------
class BarcodeGenerator:
    """Generates UPC-A barcode images and previews without third-party libraries.

    - Provides Tkinter PhotoImage preview using PPM data
    - Saves PNG files using a minimal PNG encoder (zlib-compressed)
    """

    # UPC/EAN encoding patterns
    L_PATTERNS = {
        '0': '0001101', '1': '0011001', '2': '0010011', '3': '0111101', '4': '0100011',
        '5': '0110001', '6': '0101111', '7': '0111011', '8': '0110111', '9': '0001011'
    }
    R_PATTERNS = {
        '0': '1110010', '1': '1100110', '2': '1101100', '3': '1000010', '4': '1011100',
        '5': '1001110', '6': '1010000', '7': '1000100', '8': '1001000', '9': '1110100'
    }

    @staticmethod
    def _pattern_for_upca(upc12: str) -> str:
        """Build the full 95-module pattern string (including guards) for UPC-A."""
        if len(upc12) != 12 or not upc12.isdigit():
            raise ValueError("UPC-A must be 12 digits for barcode generation")
        # Start guard, 6 left digits (L patterns), center guard, 6 right digits (R patterns), end guard
        start = '101'
        center = '01010'
        end = '101'
        left = ''.join(BarcodeGenerator.L_PATTERNS[d] for d in upc12[:6])
        right = ''.join(BarcodeGenerator.R_PATTERNS[d] for d in upc12[6:])
        pattern = start + left + center + right + end
        if len(pattern) != 95:
            raise AssertionError("UPC-A pattern must be 95 modules long")
        return pattern

    @staticmethod
    def render_pixels(upc12: str, scale: int = 3, height: int = 100, quiet: int = 9) -> Tuple[int, int, bytes]:
        """Render a monochrome barcode image as RGB bytes.

        Returns (width, height, rgb_bytes). Adds quiet zone on both sides.
        """
        pattern = BarcodeGenerator._pattern_for_upca(upc12)
        # Compute total width: quiet zones + pattern modules * scale
        width = (quiet + len(pattern) + quiet) * scale
        img_height = height
        # Build one scanline: for each module, fill scale pixels, with RGB white or black
        # We'll make the background white: (255,255,255); bars black: (0,0,0)
        row = bytearray()
        # left quiet zone (white)
        row.extend(b'\xff\xff\xff' * (quiet * scale))
        for bit in pattern:
            color = b'\x00\x00\x00' if bit == '1' else b'\xff\xff\xff'
            row.extend(color * scale)
        # right quiet
        row.extend(b'\xff\xff\xff' * (quiet * scale))
        scanline = bytes(row)
        rgb_bytes = scanline * img_height
        return width, img_height, rgb_bytes

    @staticmethod
    def _crc32(data: bytes) -> int:
        return zlib.crc32(data) & 0xffffffff

    @staticmethod
    def save_png(upc12: str, filepath: str, scale: int = 3, height: int = 100, quiet: int = 9) -> None:
        """Save the barcode as a PNG file using a minimal PNG writer."""
        w, h, rgb = BarcodeGenerator.render_pixels(upc12, scale=scale, height=height, quiet=quiet)
        # Convert RGB to raw scanlines with no filter (filter type 0)
        raw = bytearray()
        stride = w * 3
        for y in range(h):
            raw.append(0)  # filter type 0 for each row
            start = y * stride
            raw.extend(rgb[start:start+stride])
        compressed = zlib.compress(bytes(raw), level=9)

        def chunk(tag: bytes, data: bytes) -> bytes:
            return struct.pack(
                ">I", len(data)
            ) + tag + data + struct.pack(
                ">I", BarcodeGenerator._crc32(tag + data)
            )

        png_sig = b"\x89PNG\r\n\x1a\n"
        ihdr = struct.pack(
            ">IIBBBBB",
            w, h, 8, 2, 0, 0, 0  # 8-bit, color type 2 (truecolor), no interlace
        )
        idat = compressed
        iend = b""
        data = png_sig + chunk(b'IHDR', ihdr) + chunk(b'IDAT', idat) + chunk(b'IEND', iend)
        with open(filepath, 'wb') as f:
            f.write(data)

    @staticmethod
    def photoimage_from_upc(upc12: str, scale: int = 2, height: int = 80, quiet: int = 9) -> tk.PhotoImage:
        """Create a Tk PhotoImage using PPM data (no external dependencies)."""
        w, h, rgb = BarcodeGenerator.render_pixels(upc12, scale=scale, height=height, quiet=quiet)
        # Build binary PPM (P6)
        header = f"P6\n{w} {h}\n255\n".encode('ascii')
        ppm = header + rgb
        # Tk's PhotoImage expects a base64-encoded string for the data parameter
        b64 = base64.b64encode(ppm).decode('ascii')
        image = tk.PhotoImage(data=b64, format='PPM')
        return image


# ------------------------------ BARCODE SCANNER (Optional) ------------------------------
class BarcodeScanner:
    """Webcam-based barcode scanner using OpenCV and pyzbar, if available.

    This class runs scanning in a background thread and invokes a callback when a UPC is detected.
    If dependencies are missing or camera cannot be opened, the instance reports unavailable state.
    """

    def __init__(self, on_detect: Callable[[str], None]) -> None:
        self.on_detect = on_detect
        self.running = False
        self.thread: Optional[threading.Thread] = None
        self.cap = None
        self.last_emit_ts = 0.0
        self._stop_event = threading.Event()
        self.available = (cv2 is not None and pyzbar is not None)

    def start(self, camera_index: int = 0) -> bool:
        if not self.available:
            return False
        if self.running:
            return True
        try:
            self._stop_event.clear()
            self.cap = cv2.VideoCapture(camera_index)
            if not self.cap or not self.cap.isOpened():
                self.cap = None
                return False
            self.running = True
            self.thread = threading.Thread(target=self._scan_loop, daemon=True)
            self.thread.start()
            return True
        except Exception:
            self.running = False
            self.cap = None
            return False

    def stop(self) -> None:
        self._stop_event.set()
        self.running = False
        try:
            if self.cap is not None:
                try:
                    self.cap.release()
                except Exception:
                    pass
            self.cap = None
        finally:
            self.thread = None

    def _scan_loop(self) -> None:
        assert self.cap is not None
        while not self._stop_event.is_set():
            ok, frame = self.cap.read()
            if not ok:
                time.sleep(0.05)
                continue
            try:
                decoded = pyzbar.decode(frame) if pyzbar is not None else []
                for obj in decoded:
                    data = obj.data.decode('utf-8', errors='ignore')
                    symb = getattr(obj, 'type', '')
                    code = self._normalize_scanned_string(symb, data)
                    if code:
                        now = time.time()
                        if now - self.last_emit_ts > 0.8:
                            self.last_emit_ts = now
                            self.on_detect(code)
                            # Small rest to avoid bursts
                            time.sleep(0.05)
            except Exception:
                # Continue scanning even if a frame fails
                pass
            time.sleep(0.02)

    @staticmethod
    def _normalize_scanned_string(symbology: str, data: str) -> Optional[str]:
        """Normalize common scanner outputs to UPC-A/UPC-E input string.

        - Many scanners report UPC-A as EAN13 with leading '0'.
        - Accept UPC-E as-is.
        - Strip non-digits.
        """
        s = re.sub(r"\D", "", data)
        if not s:
            return None
        if symbology in ('EAN13', 'EAN-13') and s.startswith('0') and len(s) == 13:
            return s  # We accept 13 with leading 0; validator will handle
        if symbology in ('UPCA', 'UPC-A') and len(s) == 12:
            return s
        if symbology in ('UPCE', 'UPC-E') and len(s) in (6, 8):
            return s
        # Fallback: still return if plausible length
        if len(s) in (6, 8, 11, 12, 13):
            return s
        return None


# ------------------------------ PDF EXPORT (Minimal Writer) ------------------------------
class PDFExporter:
    """Very small PDF writer using the standard library only.

    It writes a single-page PDF with monospaced text lines. This is sufficient for exporting
    validation results. Fonts are core Type1 fonts available in PDF readers.
    """

    @staticmethod
    def export_text_lines(filepath: str, title: str, lines: List[str], page_size: Tuple[int, int] = (612, 792)) -> None:
        """Create a one-page PDF containing the provided title and lines.

        page_size is in points (1/72 inch). Default is US Letter (8.5x11 inches).
        """
        # PDF object assembly helpers
        objects: List[bytes] = []
        xref_positions: List[int] = []

        def add_object(obj_bytes: bytes) -> int:
            xref_positions.append(sum(len(o) for o in objects) + len(pdf_header))
            objects.append(obj_bytes)
            return len(objects)  # object number is 1-based

        def pdf_obj(obj_num: int, content: bytes) -> bytes:
            return f"{obj_num} 0 obj\n".encode('ascii') + content + b"\nendobj\n"

        width, height = page_size
        left_margin = 50
        top_margin = height - 72
        leading = 14  # line height

        # Build content stream
        content = io.StringIO()
        content.write("BT\n")
        content.write("/F1 12 Tf\n")  # font size
        content.write(f"{left_margin} {top_margin} Td\n")
        content.write(f"({PDFExporter._escape(title)}) Tj\n")
        content.write("T*\n")
        for line in lines:
            content.write(f"({PDFExporter._escape(line)}) Tj\nT*\n")
        content.write("ET\n")
        stream_data = content.getvalue().encode('latin-1')

        pdf_header = b"%PDF-1.4\n%\xe2\xe3\xcf\xd3\n"
        # objects
        catalog_num = add_object(pdf_obj(1, b"<< /Type /Catalog /Pages 2 0 R >>"))
        pages_num = add_object(pdf_obj(2, b"<< /Type /Pages /Count 1 /Kids [3 0 R] >>"))

        # Font object (Helvetica)
        font_dict = b"<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>"
        font_num = add_object(pdf_obj(5, font_dict))

        # Resources referencing font
        resources = b"<< /Font << /F1 5 0 R >> >>"

        # Content stream object
        stream_dict = f"<< /Length {len(stream_data)} >>".encode('ascii')
        content_stream = b"stream\n" + stream_data + b"endstream"
        contents_num = add_object(pdf_obj(4, stream_dict + b"\n" + content_stream))

        # Page object
        mediabox = f"[0 0 {width} {height}]".encode('ascii')
        page_dict = b"<< /Type /Page /Parent 2 0 R /MediaBox " + mediabox + b" /Resources " + resources + b" /Contents 4 0 R >>"
        page_num = add_object(pdf_obj(3, page_dict))

        # Assemble file
        with open(filepath, 'wb') as f:
            f.write(pdf_header)
            offset = len(pdf_header)
            for obj in objects:
                f.write(obj)
            xref_start = f.tell()
            f.write(f"xref\n0 {len(objects)+1}\n".encode('ascii'))
            f.write(b"0000000000 65535 f \n")
            running_offset = len(pdf_header)
            for obj in objects:
                f.write(f"{running_offset:010d} 00000 n \n".encode('ascii'))
                running_offset += len(obj)
            f.write(b"trailer\n")
            f.write(f"<< /Size {len(objects)+1} /Root 1 0 R >>\n".encode('ascii'))
            f.write(b"startxref\n")
            f.write(f"{xref_start}\n".encode('ascii'))
            f.write(b"%%EOF")

    @staticmethod
    def _escape(s: str) -> str:
        return s.replace('\\', r'\\').replace('(', r'\(').replace(')', r'\)')


# ------------------------------ MAIN APPLICATION (Tkinter) ------------------------------
class UPCApp:
    """Tkinter application implementing the full UPC Validator feature set."""

    APP_TITLE = "UPC Validator: Real-Time Barcode Checker & Decoder"

    def __init__(self, root: tk.Tk) -> None:
        self.root = root
        self.root.title(self.APP_TITLE)
        self._center_window(900, 600)
        self.root.minsize(800, 520)

        # Theming
        self.style = ttk.Style(self.root)
        # Use built-in theme; configure colors for light/dark
        available = self.style.theme_names()
        if 'clam' in available:
            self.style.theme_use('clam')
        else:
            self.style.theme_use(available[0])
        self._light_mode = True
        self._configure_styles(light=True)

        # State variables
        self.input_var = tk.StringVar()
        self.status_var = tk.StringVar(value="Enter a UPC-A (12) or UPC-E (6/8) code...")
        self.type_var = tk.StringVar(value="Type: -")
        self.product_type_var = tk.StringVar(value="Product type: -")
        self.manufacturer_var = tk.StringVar(value="Manufacturer: -")
        self.product_code_var = tk.StringVar(value="Product code: -")
        self.check_digit_var = tk.StringVar(value="Check digit: -")
        self.validation_color = "#444"
        self.preview_image: Optional[tk.PhotoImage] = None
        self.current_upca: Optional[str] = None

        # History: list of (timestamp, input, upca, type, valid)
        self.history_rows: List[Tuple[str, str, str, str, str]] = []

        # Optional scanner
        self.scanner = BarcodeScanner(on_detect=self._on_scanner_detect)

        # Build UI
        self._build_ui()

        # Bindings
        self.input_var.trace_add('write', lambda *_: self._on_input_change())
        self.root.bind('<Return>', lambda e: self._on_validate())
        self.root.bind('<Escape>', lambda e: self.root.quit())
        self.root.bind('<Control-c>', lambda e: self._on_copy())
        self.root.protocol("WM_DELETE_WINDOW", self.root.quit)

        # Splash/About dialog (simple)
        self.root.after(300, self._maybe_show_splash)

    # ---- UI construction ----
    def _build_ui(self) -> None:
        # Top-level grid weights
        self.root.rowconfigure(2, weight=1)
        self.root.columnconfigure(0, weight=1)

        # Header
        header = ttk.Frame(self.root, padding=(16, 12))
        header.grid(row=0, column=0, sticky='ew')
        header.columnconfigure(0, weight=1)
        title = ttk.Label(header, text=self.APP_TITLE, style='Header.TLabel')
        title.grid(row=0, column=0, sticky='w')
        mode_btn = ttk.Button(header, text="Toggle Light/Dark", command=self._toggle_mode)
        mode_btn.grid(row=0, column=1, sticky='e', padx=(12, 0))

        # Input section
        input_frame = ttk.Frame(self.root, padding=(16, 8))
        input_frame.grid(row=1, column=0, sticky='ew')
        for c in range(8):
            input_frame.columnconfigure(c, weight=1)

        entry = ttk.Entry(input_frame, textvariable=self.input_var, font=('Segoe UI', 14))
        entry.grid(row=0, column=0, columnspan=5, sticky='ew', padx=(0, 8))
        entry.focus_set()

        validate_btn = self._mk_button(input_frame, "✅ Validate", self._on_validate)
        validate_btn.grid(row=0, column=5, sticky='ew')
        clear_btn = self._mk_button(input_frame, "🧹 Clear", self._on_clear)
        clear_btn.grid(row=0, column=6, sticky='ew', padx=(6, 0))
        exit_btn = self._mk_button(input_frame, "⏻ Exit", self.root.quit)
        exit_btn.grid(row=0, column=7, sticky='ew', padx=(6, 0))

        copy_btn = self._mk_button(input_frame, "📋 Copy", self._on_copy)
        copy_btn.grid(row=1, column=5, sticky='ew', pady=(8, 0))
        paste_btn = self._mk_button(input_frame, "📥 Paste", self._on_paste)
        paste_btn.grid(row=1, column=6, sticky='ew', padx=(6, 0), pady=(8, 0))
        scan_text = "📷 Start Scanner" if self.scanner.available else "📷 Scanner Unavailable"
        self.scan_btn = self._mk_button(input_frame, scan_text, self._on_toggle_scanner)
        self.scan_btn.state(["!disabled"] if self.scanner.available else ["disabled"])
        self.scan_btn.grid(row=1, column=7, sticky='ew', padx=(6, 0), pady=(8, 0))

        # Status line
        status = ttk.Label(self.root, textvariable=self.status_var, style='Status.TLabel')
        status.grid(row=2, column=0, sticky='ew', padx=16)

        # Main content: results + preview + history
        main = ttk.Frame(self.root, padding=(16, 8))
        main.grid(row=3, column=0, sticky='nsew')
        main.columnconfigure(0, weight=2)
        main.columnconfigure(1, weight=1)
        main.rowconfigure(1, weight=1)

        # Results box
        results = ttk.Labelframe(main, text="Decoded Details", padding=(12, 10))
        results.grid(row=0, column=0, sticky='nsew', padx=(0, 8))
        for r in range(4):
            results.rowconfigure(r, weight=1)
        results.columnconfigure(1, weight=1)

        type_lbl = ttk.Label(results, textvariable=self.type_var)
        type_lbl.grid(row=0, column=0, columnspan=2, sticky='w')
        prod_lbl = ttk.Label(results, textvariable=self.product_type_var)
        prod_lbl.grid(row=1, column=0, columnspan=2, sticky='w')
        man_lbl = ttk.Label(results, textvariable=self.manufacturer_var)
        man_lbl.grid(row=2, column=0, columnspan=2, sticky='w')
        code_lbl = ttk.Label(results, textvariable=self.product_code_var)
        code_lbl.grid(row=3, column=0, columnspan=2, sticky='w')
        chk_lbl = ttk.Label(results, textvariable=self.check_digit_var)
        chk_lbl.grid(row=4, column=0, columnspan=2, sticky='w')

        # Barcode preview panel
        preview = ttk.Labelframe(main, text="Barcode Generator & Preview", padding=(12, 10))
        preview.grid(row=0, column=1, sticky='nsew')
        preview.columnconfigure(0, weight=1)
        preview.rowconfigure(0, weight=1)

        self.preview_canvas = tk.Canvas(preview, width=260, height=120, highlightthickness=0, bg=self._bg_color())
        self.preview_canvas.grid(row=0, column=0, sticky='nsew')

        gen_btn = self._mk_button(preview, "🖨️ Generate Preview", self._on_generate_barcode)
        gen_btn.grid(row=1, column=0, sticky='ew', pady=(8, 0))
        save_btn = self._mk_button(preview, "💾 Save PNG", self._on_save_barcode)
        save_btn.grid(row=2, column=0, sticky='ew', pady=(8, 0))

        # History table
        history = ttk.Labelframe(main, text="Validation History", padding=(12, 10))
        history.grid(row=1, column=0, columnspan=2, sticky='nsew', pady=(8, 0))
        history.rowconfigure(0, weight=1)
        history.columnconfigure(0, weight=1)

        columns = ("timestamp", "input", "upca", "type", "valid")
        self.tree = ttk.Treeview(history, columns=columns, show='headings', height=6)
        for col, text in zip(columns, ("Time", "Input", "UPC-A", "Type", "Valid")):
            self.tree.heading(col, text=text)
            self.tree.column(col, width=120 if col != 'input' else 220, anchor='w')
        self.tree.grid(row=0, column=0, sticky='nsew')
        yscroll = ttk.Scrollbar(history, orient='vertical', command=self.tree.yview)
        self.tree.configure(yscroll=yscroll.set)
        yscroll.grid(row=0, column=1, sticky='ns')

        # History buttons
        hist_btns = ttk.Frame(history)
        hist_btns.grid(row=1, column=0, columnspan=2, sticky='ew', pady=(8, 0))
        imp_btn = self._mk_button(hist_btns, "📂 Import UPCs", self._on_import_batch)
        imp_btn.pack(side='left')
        exp_csv_btn = self._mk_button(hist_btns, "📤 Export CSV", self._on_export_csv)
        exp_csv_btn.pack(side='left', padx=(8, 0))
        exp_pdf_btn = self._mk_button(hist_btns, "📄 Export PDF", self._on_export_pdf)
        exp_pdf_btn.pack(side='left', padx=(8, 0))
        save_hist_btn = self._mk_button(hist_btns, "💾 Save History", self._on_save_history)
        save_hist_btn.pack(side='left', padx=(8, 0))
        load_hist_btn = self._mk_button(hist_btns, "📥 Load History", self._on_load_history)
        load_hist_btn.pack(side='left', padx=(8, 0))
        clear_hist_btn = self._mk_button(hist_btns, "🧹 Clear History", self._on_clear_history)
        clear_hist_btn.pack(side='left', padx=(8, 0))

        # Progress bar for batch
        self.progress = ttk.Progressbar(hist_btns, mode='determinate', length=220)
        self.progress.pack(side='right')

        # Menu (About)
        menubar = tk.Menu(self.root)
        helpmenu = tk.Menu(menubar, tearoff=0)
        helpmenu.add_command(label="About", command=self._show_about)
        menubar.add_cascade(label="Help", menu=helpmenu)
        self.root.config(menu=menubar)

    def _mk_button(self, parent: tk.Widget, text: str, cmd: Callable[[], None]) -> ttk.Button:
        btn = ttk.Button(parent, text=text, command=cmd, style='Action.TButton')
        # Hover effects
        def on_enter(_):
            btn.configure(style='ActionHover.TButton')
        def on_leave(_):
            btn.configure(style='Action.TButton')
        btn.bind('<Enter>', on_enter)
        btn.bind('<Leave>', on_leave)
        return btn

    # ---- Theming ----
    def _configure_styles(self, light: bool) -> None:
        bg = '#f0f0f0' if light else '#1f1f1f'
        fg = '#1a3d8f' if light else '#93b4ff'
        text = '#111' if light else '#eee'
        status = '#333' if light else '#ccc'
        btn_bg = '#e6eefc' if light else '#2b3a55'
        btn_bg_hover = '#d4e3ff' if light else '#364b6e'
        self.root.configure(bg=bg)
        self.style.configure('TFrame', background=bg)
        self.style.configure('TLabel', background=bg, foreground=text)
        self.style.configure('Header.TLabel', background=bg, foreground=fg, font=('Segoe UI', 18, 'bold'))
        self.style.configure('Status.TLabel', background=bg, foreground=status, font=('Segoe UI', 10))
        self.style.configure('TLabelframe', background=bg, foreground=text)
        self.style.configure('TLabelframe.Label', background=bg, foreground=text)
        self.style.configure('TEntry', fieldbackground='white', foreground='black')
        self.style.configure('Action.TButton', padding=6)
        self.style.map('Action.TButton', background=[('!active', btn_bg)], foreground=[('!active', '#111')])
        self.style.configure('ActionHover.TButton', padding=6)
        self.style.map('ActionHover.TButton', background=[('!active', btn_bg_hover)], foreground=[('!active', '#111')])

    def _toggle_mode(self) -> None:
        self._light_mode = not self._light_mode
        self._configure_styles(light=self._light_mode)

    def _bg_color(self) -> str:
        return '#f0f0f0' if self._light_mode else '#1f1f1f'

    # ---- Event handlers ----
    def _on_input_change(self) -> None:
        s = UPCValidator.sanitize(self.input_var.get())
        # Avoid runaway recursion by only setting when modified
        if s != self.input_var.get():
            self.input_var.set(s)
            return
        # Real-time validation feedback
        info = UPCValidator.validate(s)
        self._render_validation(info, realtime=True)

    def _on_validate(self) -> None:
        s = self.input_var.get()
        info = UPCValidator.validate(s)
        self._render_validation(info, realtime=False)
        if info.get('valid'):
            self._beep_success()

    def _on_clear(self) -> None:
        self.input_var.set('')
        self.type_var.set("Type: -")
        self.product_type_var.set("Product type: -")
        self.manufacturer_var.set("Manufacturer: -")
        self.product_code_var.set("Product code: -")
        self.check_digit_var.set("Check digit: -")
        self.status_var.set("Cleared.")
        self._set_status_color('neutral')
        self.current_upca = None
        self.preview_image = None
        self.preview_canvas.delete('all')

    def _on_copy(self) -> None:
        try:
            self.root.clipboard_clear()
            self.root.clipboard_append(self.input_var.get())
            self.status_var.set("Copied to clipboard.")
        except Exception:
            messagebox.showerror("Copy Error", "Failed to copy to clipboard.")

    def _on_paste(self) -> None:
        try:
            text = self.root.clipboard_get()
            self.input_var.set(UPCValidator.sanitize(text))
        except Exception:
            messagebox.showerror("Paste Error", "No text on clipboard.")

    def _on_toggle_scanner(self) -> None:
        if not self.scanner.available:
            messagebox.showwarning(
                "Scanner Unavailable",
                "OpenCV (cv2) and pyzbar are required for scanning. Install them to enable this feature."
            )
            return
        if self.scanner.running:
            self.scanner.stop()
            self.scan_btn.configure(text="📷 Start Scanner")
            self.status_var.set("Scanner stopped.")
        else:
            ok = self.scanner.start()
            if ok:
                self.scan_btn.configure(text="⏹ Stop Scanner")
                self.status_var.set("Scanner started. Present a UPC to the camera...")
            else:
                messagebox.showerror("Scanner Error", "Could not access the camera.")

    def _on_scanner_detect(self, code: str) -> None:
        # Called from scanner background thread; marshal into Tk thread
        self.root.after(0, lambda: self._on_scanner_detect_main(code))

    def _on_scanner_detect_main(self, code: str) -> None:
        self.input_var.set(code)
        self.status_var.set("Scanned code captured.")
        self._on_validate()

    def _on_generate_barcode(self) -> None:
        try:
            info = UPCValidator.validate(self.input_var.get())
            if not info.get('valid'):
                messagebox.showwarning("Invalid UPC", "Please provide a valid UPC-A/UPC-E before generating a barcode.")
                return
            upca = info.get('upca')  # type: ignore
            assert isinstance(upca, str)
            self.current_upca = upca
            img = BarcodeGenerator.photoimage_from_upc(upca)
            self.preview_image = img
            self.preview_canvas.delete('all')
            self.preview_canvas.create_image(10, 10, anchor='nw', image=img)
            self.status_var.set("Barcode preview generated.")
        except Exception:
            messagebox.showerror("Barcode Error", "Failed to generate barcode preview.")

    def _on_save_barcode(self) -> None:
        if not self.current_upca:
            messagebox.showinfo("No Barcode", "Generate a barcode preview first.")
            return
        path = filedialog.asksaveasfilename(
            defaultextension=".png",
            filetypes=[("PNG Image", "*.png")],
            title="Save Barcode as PNG"
        )
        if not path:
            return
        try:
            BarcodeGenerator.save_png(self.current_upca, path)
            self.status_var.set(f"Saved barcode to: {path}")
        except Exception:
            messagebox.showerror("Save Error", "Failed to save PNG file.")

    def _on_import_batch(self) -> None:
        path = filedialog.askopenfilename(
            title="Import UPCs (TXT/CSV)",
            filetypes=[("Text/CSV", "*.txt *.csv"), ("All Files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, 'r', newline='', encoding='utf-8', errors='ignore') as f:
                lines = [line.strip() for line in f if line.strip()]
        except Exception:
            messagebox.showerror("Import Error", "Failed to read the file.")
            return

        total = len(lines)
        if total == 0:
            messagebox.showinfo("No Data", "No UPCs found in the selected file.")
            return

        self.progress.configure(maximum=total, value=0)
        self.status_var.set(f"Processing {total} UPCs...")

        def worker():
            count = 0
            for line in lines:
                info = UPCValidator.validate(line)
                timestamp = time.strftime('%H:%M:%S')
                upca = info.get('upca') if info.get('upca') else ''
                vtype = info.get('type') if info.get('type') else ''
                valid = 'VALID' if info.get('valid') else 'INVALID'
                self.history_rows.append((timestamp, line, str(upca), str(vtype), valid))
                self.root.after(0, lambda row=self.history_rows[-1]: self.tree.insert('', 'end', values=row))
                count += 1
                self.root.after(0, lambda c=count: self.progress.configure(value=c))
                time.sleep(0.002)
            self.root.after(0, lambda: self.status_var.set(f"Batch complete: {count} processed."))

        threading.Thread(target=worker, daemon=True).start()

    def _on_export_csv(self) -> None:
        if not self.history_rows:
            messagebox.showinfo("No Data", "No history to export.")
            return
        path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV", "*.csv")],
            title="Export Results to CSV"
        )
        if not path:
            return
        try:
            with open(path, 'w', newline='', encoding='utf-8') as f:
                w = csv.writer(f)
                w.writerow(["Time", "Input", "UPC-A", "Type", "Valid"])
                for row in self.history_rows:
                    w.writerow(row)
            self.status_var.set(f"Exported CSV to: {path}")
        except Exception:
            messagebox.showerror("Export Error", "Failed to write CSV file.")

    def _on_export_pdf(self) -> None:
        if not self.history_rows:
            messagebox.showinfo("No Data", "No history to export.")
            return
        path = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF", "*.pdf")],
            title="Export Results to PDF"
        )
        if not path:
            return
        title = "UPC Validation Results"
        lines = ["Time | Input | UPC-A | Type | Valid"]
        for t, inp, upc, typ, valid in self.history_rows:
            lines.append(f"{t} | {inp} | {upc} | {typ} | {valid}")
        try:
            PDFExporter.export_text_lines(path, title, lines)
            self.status_var.set(f"Exported PDF to: {path}")
        except Exception:
            messagebox.showerror("Export Error", "Failed to write PDF file.")

    def _on_save_history(self) -> None:
        if not self.history_rows:
            messagebox.showinfo("No Data", "No history to save.")
            return
        path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV", "*.csv")],
            title="Save History"
        )
        if not path:
            return
        try:
            with open(path, 'w', newline='', encoding='utf-8') as f:
                w = csv.writer(f)
                w.writerow(["Time", "Input", "UPC-A", "Type", "Valid"])
                w.writerows(self.history_rows)
            self.status_var.set(f"Saved history to: {path}")
        except Exception:
            messagebox.showerror("Save Error", "Failed to save history.")

    def _on_load_history(self) -> None:
        path = filedialog.askopenfilename(
            title="Load History (CSV)",
            filetypes=[("CSV", "*.csv"), ("All Files", "*.*")]
        )
        if not path:
            return
        try:
            with open(path, 'r', newline='', encoding='utf-8', errors='ignore') as f:
                r = csv.reader(f)
                header = next(r, None)
                rows = [tuple(row) for row in r if row]
            self.history_rows = [(str(a), str(b), str(c), str(d), str(e)) for a, b, c, d, e in rows]
            # Refresh table
            for item in self.tree.get_children():
                self.tree.delete(item)
            for row in self.history_rows:
                self.tree.insert('', 'end', values=row)
            self.status_var.set(f"Loaded history from: {path}")
        except Exception:
            messagebox.showerror("Load Error", "Failed to load history CSV.")

    def _on_clear_history(self) -> None:
        self.history_rows.clear()
        for item in self.tree.get_children():
            self.tree.delete(item)
        self.status_var.set("History cleared.")

    # ---- Rendering & helpers ----
    def _render_validation(self, info: Dict[str, object], realtime: bool = False) -> None:
        # Update status label
        valid = bool(info.get('valid'))
        complete = bool(info.get('complete'))
        error = info.get('error')
        upca = info.get('upca')
        detected_type = info.get('type') or '-'

        if valid and complete:
            self.status_var.set("VALID UPC ✅")
            self._set_status_color('green')
        else:
            if error:
                msg = str(error)
            else:
                msg = "Incomplete input" if not complete else "Invalid input"
            self.status_var.set(msg)
            if 'Incomplete' in msg or '?' in (info.get('sanitized') or ''):
                self._set_status_color('warn')
            else:
                self._set_status_color('red')

        # Decoded details if available
        if valid and upca:
            upca_str = str(upca)
            decoded = info.get('decoded') or {}
            self.type_var.set(f"Type: {detected_type}")
            self.product_type_var.set(f"Product type: {decoded.get('product_type_digit', '-')}: {decoded.get('product_type_meaning', '-')} ")
            self.manufacturer_var.set(f"Manufacturer: {decoded.get('manufacturer', '-')}")
            self.product_code_var.set(f"Product code: {decoded.get('product_code', '-')}")
            self.check_digit_var.set(f"Check digit: {decoded.get('check_digit', '-')}")
            self.current_upca = upca_str
            # Add to history in real time (avoid multiple duplicates while typing rapidly)
            if not realtime:
                self._append_history(self.input_var.get(), upca_str, str(detected_type), True)
        else:
            self.current_upca = None
            if not realtime and self.input_var.get():
                self._append_history(self.input_var.get(), '', str(detected_type), False)

        # If solved, propose filling character (auto-filled via recursive validate already)
        solved = info.get('solved')
        if solved:
            idx, digit = solved  # type: ignore
            self.status_var.set(f"Solved unknown at pos {int(idx)+1}: {digit}")

    def _append_history(self, raw_input: str, upca: str, vtype: str, is_valid: bool) -> None:
        ts = time.strftime('%H:%M:%S')
        row = (ts, raw_input, upca, vtype, 'VALID' if is_valid else 'INVALID')
        self.history_rows.append(row)
        self.tree.insert('', 'end', values=row)

    def _set_status_color(self, kind: str) -> None:
        # Change status label color for quick feedback
        if kind == 'green':
            color = '#0f8a0f'
        elif kind == 'red':
            color = '#c62828'
        elif kind == 'warn':
            color = '#e67e22'
        else:
            color = '#444'
        self.style.configure('Status.TLabel', foreground=color)

    def _beep_success(self) -> None:
        try:
            if winsound:
                winsound.MessageBeep(winsound.MB_ICONASTERISK)
            else:
                self.root.bell()
        except Exception:
            pass

    def _maybe_show_splash(self) -> None:
        # Simple About on first load
        self._show_about()

    def _show_about(self) -> None:
        message = (
            "UPC Validator\n"
            "Validate UPC-A and UPC-E codes, generate barcodes, scan via webcam (if available),\n"
            "and export results. Built with Tkinter and pure Python."
        )
        messagebox.showinfo("About", message)

    def _center_window(self, width: int, height: int) -> None:
        self.root.update_idletasks()
        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()
        x = (screen_w // 2) - (width // 2)
        y = (screen_h // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")


# ------------------------------ Application Entrypoint ------------------------------

def main() -> None:
    root = tk.Tk()
    app = UPCApp(root)
    root.mainloop()


if __name__ == '__main__':
    try:
        main()
    except Exception as exc:
        # If something fails at startup, show a dialog to assist the user
        traceback.print_exc()
        try:
            messagebox.showerror("Application Error", f"An error occurred:\n{exc}")
        except Exception:
            print(f"Application Error: {exc}")
